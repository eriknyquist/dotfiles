export VIM_CTAGS_FTYPES=*.c,*.h,*.py,*.sh,*.mk,*Makefile,*.tex,*.vim
export VIM_CTAGS_FILE=.tags

update_ctags () {
    VIM_CTAGS_FILE=".tags"

    TOPDIR=$(git rev-parse --show-toplevel)
    # Bail if not in a git repository
    [ $? -eq 0 ] || return

    # Bail if no tags file already exists
    [ -f $TOPDIR/$VIM_CTAGS_FILE ] || return

    # Get filename relative to repo root, then add backslashes
    # before '.' and '/' to make it suitable for a sed pattern
    RELFNAME=$(realpath --relative-to=$TOPDIR $1)
    [ $? -eq 0 ] || return

    # Need the absolute path to check if file is in git repo
    ABSFNAME=$(realpath $1)
    [ $? -eq 0 ] || return

    if [ "${ABSFNAME##$TOPDIR}" == "${ABSFNAME}" ]
    then
        # Target file is not in the current git repository
        exit
    fi

    # Add backslashes before '.' and '/' to make filename
    # suitable for a sed pattern
    ESCFNAME=$(echo $RELFNAME | sed 's/\//\\\//g; s/\./\\\./g')
    [ $? -eq 0 ] || return

    cd $TOPDIR

    # Remove all tags for this file from tags file
    sed -i "/$ESCFNAME/d" $VIM_CTAGS_FILE
    [ $? -eq 0 ] || return

    # Re-generate tags for this file and append to tags file
    ctags -a -f $VIM_CTAGS_FILE $RELFNAME
    cd -
}

cproj() {
    if [ $# -lt 1 ] || [ $# -gt 2 ]
    then
        echo "Usage: $0 <project_name> [<directory>]"
        return
    fi

    projname=$1
    guard=$(echo $projname | awk '{print toupper($0)}')_H

    if [ $# -eq 2 ]
    then
        directory=$2/
    else
        directory=$projname/
    fi

    [ -d $directory ] || mkdir -p $directory

    cat > $directory$projname.h << EOF
#ifndef $guard
#define $guard



#endif
EOF

    cat > $directory$projname.c << EOF
#include "$projname.h"


EOF

    cat > $directory'main.c' << EOF
#include "$projname.h"

int main(int argc, char *argv[])
{

}
EOF

    cat > $directory'Makefile' << EOF
OBJ= \$(patsubst %.c,%.o,\$(wildcard *.c))
PROGNAME=$projname

.PHONY: clean

%: %.c

all: \$(PROGNAME)

\$(PROGNAME): \$(OBJ)
	\$(CC) $^ -o \$@ \$(CFLAGS) \$(LDFLAGS)

clean:
	rm -f *.o
	rm -f \$(PROGNAME)
EOF
}

parse_git_branch() {
     git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ \1/'
}

export PS1="\u@\h \[\033[32m\]\w\[\033[33m\]\$(parse_git_branch)\[\033[00m\] $ "
